#include <stdio.h>#include <stdlib.h>// LISTAS SIMPLESMENTE ENCADEADAS//-----------------------------------------------//TIPO DE ELEMENTOS DA LISTA ENCADEADAstruct TNo{	int Numero;	struct TNo *Prox;};//-----------------------------------------------// TNo = STRUCT TNotypedef struct TNo TNo;//-----------------------------------------------//VERIFICA SE A CABECA ESTA VAZIAbool Vazia(TNo *pLista){	if(pLista == NULL)		return true;		else		return false;}//-----------------------------------------------//INCLUSAO DE ELEMENTOS NA CABECA  - O(1)TNo *IncluiCabeca(TNo *pLista, int pValor){	//Caso exista um ponteiro para estrutura TNo valida	if(Vazia(pLista) == false)	{		TNo *pNovoNo;									//Declara um ponteiro para a nova estrutura		pNovoNo = (TNo *) malloc(sizeof(TNo));			//Aloca o tamanho da estrutura para o ponteiro		pNovoNo->Numero = pValor;						//Campo Numero = pValor		pNovoNo->Prox = pLista;							//Campo Proximo No = pLista(Cabeca atual)		pLista = pNovoNo;								//pLista recebe ponteiro para nova cabeca	}	else	{		TNo *pNovoNo;		pNovoNo = (TNo *) malloc(sizeof(TNo));		pNovoNo->Numero = pValor;		pNovoNo->Prox = NULL;							//Unico elemento da lista		pLista = pNovoNo;	}	return pLista;}//-----------------------------------------------//EXCLUSAO DE ELEMENTOS NA CABECA - O(1)TNo *ExcluiCabeca(TNo *pLista){	if( Vazia(pLista) == false)	{		TNo *pAux;		pAux = pLista;		pLista = pLista->Prox;		free(pAux);			}	return pLista;}//-----------------------------------------------//INCLUSAO DE ELEMENTOS NA CALDA - O(N)TNo *IncluiCalda(TNo *pLista, int pValor){	if(Vazia(pLista) == true)	{		return (IncluiCabeca(pLista, pValor));	}	else	{		TNo *pNovoNo, *pAux;		pNovoNo = (TNo *) malloc(sizeof(TNo));		pNovoNo->Numero = pValor;		pNovoNo->Prox = NULL;		pAux = pLista;			while (pAux->Prox != NULL)			pAux = pAux->Prox;		pAux->Prox = pNovoNo;		return pLista;	}}//-----------------------------------------------//EXCLUSAO DE ELEMENTOS NA CALDA - O(N)TNo *ExcluiCalda(TNo *pLista){	if(Vazia(pLista) == false)	{			TNo *pAux;		pAux = pLista;		while (pAux->Prox->Prox != NULL)			pAux = pAux->Prox;				free(pAux->Prox);		pAux->Prox = NULL;	}	return pLista;}//-----------------------------------------------//EXCLUSAO DE CHAVE - O(N) no pior dos casosTNo *ExcluiChave(TNo *pLista, int pChave){	if(Vazia(pLista) == false)	{		TNo *pAnt, *pPost;		pAnt = pLista;				while ((pAnt->Prox->Numero != pChave) || (pAnt->Prox->Prox == NULL))			pAnt = pAnt->Prox;				if((pAnt->Prox->Prox == NULL) && (pAnt->Prox->Numero != pChave))		{			printf("Chave nao localizada\n");			return pLista;		}			pPost = pAnt->Prox->Prox;		free(pAnt->Prox);		pAnt->Prox = pPost ;	}	return pLista;}//-----------------------------------------------//INCLUI ANTES DA CHAVE - O(N)TNo *IncluiAntes(TNo *pLista, int pChave, int pValor){	if(Vazia(pLista) == false)	{		TNo *pAnt;		pAnt = pLista;				while ((pAnt->Prox->Numero != pChave) || (pAnt->Prox->Prox == NULL))			pAnt = pAnt->Prox;				if((pAnt->Prox->Prox == NULL) && (pAnt->Prox->Numero != pChave))		{			printf("Chave nao localizada\n");			return pLista;		}				TNo *pNovoNo;									//Declara um ponteiro para a nova estrutura		pNovoNo = (TNo *) malloc(sizeof(TNo));			//Aloca o tamanho da estrutura para o ponteiro		pNovoNo->Numero = pValor;						//Campo Numero = pValor		pNovoNo->Prox = pAnt->Prox;						//Campo Proximo No = pAnt-> prox, inclui antes da chave		pAnt->Prox = pNovoNo;							//pAnt aponta para o novo elemento antes da chave	}		return pLista;}